#!/usr/bin/env python3
"""
ModuleCreator - Scaffold new Python modules with tests and documentation

Automatically generates:
- Module file with proper structure
- Unit test file with pytest
- Documentation strings
- __init__.py updates
- Integration points

Features:
- Template-based generation
- Best practice enforcement
- Automatic test scaffolding
- Documentation generation
"""
from __future__ import annotations
from typing import Dict, List, Any, Optional
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime
import os
import logging

logger = logging.getLogger(__name__)


@dataclass
class ModuleSpec:
    """Specification for creating a new module"""
    name: str  # Module name (snake_case)
    description: str
    classes: List[Dict[str, Any]]  # List of classes to create
    functions: List[Dict[str, Any]]  # List of standalone functions
    dependencies: List[str]  # Required packages
    integrations: List[str]  # Modules to integrate with
    has_cli: bool = False  # Whether to include CLI interface
    has_config: bool = False  # Whether to include config loading
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'name': self.name,
            'description': self.description,
            'classes': self.classes,
            'functions': self.functions,
            'dependencies': self.dependencies,
            'integrations': self.integrations,
            'has_cli': self.has_cli,
            'has_config': self.has_config
        }


@dataclass
class GeneratedModule:
    """Result of module generation"""
    module_file: str  # Path to generated module
    test_file: str  # Path to generated test file
    module_content: str  # Module code
    test_content: str  # Test code
    dependencies: List[str]  # Required pip packages
    integration_notes: str  # How to integrate this module


class ModuleCreator:
    """Create new Python modules with best practices"""
    
    def __init__(self, saraphina_root: str = "D:\\Saraphina Root\\saraphina"):
        self.saraphina_root = Path(saraphina_root)
        self.templates_dir = self.saraphina_root.parent / "templates"
    
    def create_module(self, spec: ModuleSpec) -> GeneratedModule:
        """
        Create a new module from specification.
        
        Args:
            spec: ModuleSpec with module details
        
        Returns:
            GeneratedModule with paths and content
        """
        logger.info(f"Creating module: {spec.name}")
        
        # Generate module content
        module_content = self._generate_module_code(spec)
        
        # Generate test content
        test_content = self._generate_test_code(spec)
        
        # Determine file paths
        module_file = str(self.saraphina_root / f"{spec.name}.py")
        test_file = str(self.saraphina_root.parent / "tests" / f"test_{spec.name}.py")
        
        # Generate integration notes
        integration_notes = self._generate_integration_notes(spec)
        
        return GeneratedModule(
            module_file=module_file,
            test_file=test_file,
            module_content=module_content,
            test_content=test_content,
            dependencies=spec.dependencies,
            integration_notes=integration_notes
        )
    
    def _generate_module_code(self, spec: ModuleSpec) -> str:
        """Generate the main module code"""
        lines = []
        
        # Header
        lines.extend([
            '#!/usr/bin/env python3',
            '"""',
            f'{spec.name.replace("_", " ").title()}',
            '',
            spec.description,
            '',
            f'Created: {datetime.now().strftime("%Y-%m-%d")}',
            f'Auto-generated by ModuleCreator',
            '"""',
            'from __future__ import annotations',
            'from typing import Dict, List, Any, Optional',
            'from pathlib import Path',
            'from dataclasses import dataclass',
            'import logging',
            ''
        ])
        
        # Add imports for dependencies
        if spec.dependencies:
            for dep in spec.dependencies:
                # Common import patterns
                if dep in ['requests', 'json', 'time', 're', 'os', 'sys']:
                    lines.append(f'import {dep}')
            lines.append('')
        
        # Logger
        lines.extend([
            'logger = logging.getLogger(__name__)',
            '',
            ''
        ])
        
        # Generate classes
        for class_spec in spec.classes:
            class_code = self._generate_class_code(class_spec)
            lines.extend(class_code)
            lines.append('')
            lines.append('')
        
        # Generate standalone functions
        for func_spec in spec.functions:
            func_code = self._generate_function_code(func_spec)
            lines.extend(func_code)
            lines.append('')
            lines.append('')
        
        # Add CLI interface if requested
        if spec.has_cli:
            lines.extend(self._generate_cli_code(spec))
        
        return '\n'.join(lines)
    
    def _generate_class_code(self, class_spec: Dict[str, Any]) -> List[str]:
        """Generate code for a single class"""
        lines = []
        
        class_name = class_spec.get('name', 'MyClass')
        description = class_spec.get('description', 'Class description')
        methods = class_spec.get('methods', [])
        
        # Class definition
        lines.extend([
            f'class {class_name}:',
            f'    """',
            f'    {description}',
            f'    """',
            f'    ',
            f'    def __init__(self):',
            f'        """Initialize {class_name}"""',
            f'        pass',
            f'    '
        ])
        
        # Generate methods
        for method in methods:
            method_code = self._generate_method_code(method)
            lines.extend([f'    {line}' for line in method_code])
            lines.append('    ')
        
        return lines
    
    def _generate_method_code(self, method_spec: Dict[str, Any]) -> List[str]:
        """Generate code for a single method"""
        lines = []
        
        name = method_spec.get('name', 'method')
        description = method_spec.get('description', 'Method description')
        params = method_spec.get('parameters', [])
        returns = method_spec.get('returns', 'None')
        
        # Method signature
        param_str = ', '.join([p['name'] for p in params])
        lines.extend([
            f'def {name}(self, {param_str}):',
            f'    """',
            f'    {description}',
            f'    ',
        ])
        
        # Parameters documentation
        if params:
            lines.append('    Args:')
            for param in params:
                param_name = param['name']
                param_desc = param.get('description', 'Parameter')
                param_type = param.get('type', 'Any')
                lines.append(f'        {param_name} ({param_type}): {param_desc}')
            lines.append('    ')
        
        # Returns documentation
        lines.extend([
            f'    Returns:',
            f'        {returns}',
            f'    """',
            f'    # TODO: Implement {name}',
            f'    raise NotImplementedError("Method {name} not yet implemented")',
        ])
        
        return lines
    
    def _generate_function_code(self, func_spec: Dict[str, Any]) -> List[str]:
        """Generate code for a standalone function"""
        lines = []
        
        name = func_spec.get('name', 'function')
        description = func_spec.get('description', 'Function description')
        params = func_spec.get('parameters', [])
        returns = func_spec.get('returns', 'None')
        
        # Function signature
        param_str = ', '.join([f"{p['name']}: {p.get('type', 'Any')}" for p in params])
        return_type = returns if returns != 'None' else 'None'
        
        lines.extend([
            f'def {name}({param_str}) -> {return_type}:',
            f'    """',
            f'    {description}',
            f'    ',
        ])
        
        # Parameters documentation
        if params:
            lines.append('    Args:')
            for param in params:
                param_name = param['name']
                param_desc = param.get('description', 'Parameter')
                lines.append(f'        {param_name}: {param_desc}')
            lines.append('    ')
        
        # Returns documentation
        lines.extend([
            f'    Returns:',
            f'        {returns}',
            f'    """',
            f'    # TODO: Implement {name}',
            f'    raise NotImplementedError("Function {name} not yet implemented")',
        ])
        
        return lines
    
    def _generate_cli_code(self, spec: ModuleSpec) -> List[str]:
        """Generate CLI interface code"""
        lines = [
            '# CLI Interface',
            'if __name__ == "__main__":',
            '    import sys',
            '    import argparse',
            '    ',
            '    parser = argparse.ArgumentParser(',
            f'        description="{spec.description}"',
            '    )',
            '    ',
            '    # Add arguments here',
            '    parser.add_argument("--verbose", "-v", action="store_true",',
            '                        help="Enable verbose output")',
            '    ',
            '    args = parser.parse_args()',
            '    ',
            '    if args.verbose:',
            '        logging.basicConfig(level=logging.DEBUG)',
            '    else:',
            '        logging.basicConfig(level=logging.INFO)',
            '    ',
            f'    # TODO: Implement CLI for {spec.name}',
            '    print(f"Running {spec.name}...")',
        ]
        
        return lines
    
    def _generate_test_code(self, spec: ModuleSpec) -> str:
        """Generate test file code"""
        lines = []
        
        # Header
        lines.extend([
            '#!/usr/bin/env python3',
            '"""',
            f'Tests for {spec.name}',
            '',
            f'Auto-generated by ModuleCreator',
            f'Created: {datetime.now().strftime("%Y-%m-%d")}',
            '"""',
            'import pytest',
            'from pathlib import Path',
            'import sys',
            '',
            '# Add saraphina to path',
            'sys.path.insert(0, str(Path(__file__).parent.parent / "saraphina"))',
            '',
            f'from saraphina.{spec.name} import *',
            '',
            ''
        ])
        
        # Generate test classes
        for class_spec in spec.classes:
            test_class_code = self._generate_test_class_code(class_spec, spec.name)
            lines.extend(test_class_code)
            lines.append('')
            lines.append('')
        
        # Generate test functions
        for func_spec in spec.functions:
            test_func_code = self._generate_test_function_code(func_spec)
            lines.extend(test_func_code)
            lines.append('')
            lines.append('')
        
        # Add integration tests if needed
        if spec.integrations:
            lines.extend(self._generate_integration_tests(spec))
        
        return '\n'.join(lines)
    
    def _generate_test_class_code(self, class_spec: Dict[str, Any], module_name: str) -> List[str]:
        """Generate test class for a module class"""
        lines = []
        
        class_name = class_spec.get('name', 'MyClass')
        
        lines.extend([
            f'class Test{class_name}:',
            f'    """Tests for {class_name}"""',
            f'    ',
            f'    def test_init(self):',
            f'        """Test initialization"""',
            f'        obj = {class_name}()',
            f'        assert obj is not None',
            f'    ',
        ])
        
        # Generate test methods
        methods = class_spec.get('methods', [])
        for method in methods:
            method_name = method.get('name', 'method')
            lines.extend([
                f'    def test_{method_name}(self):',
                f'        """Test {method_name}"""',
                f'        obj = {class_name}()',
                f'        # TODO: Implement test for {method_name}',
                f'        with pytest.raises(NotImplementedError):',
                f'            obj.{method_name}()',
                f'    ',
            ])
        
        return lines
    
    def _generate_test_function_code(self, func_spec: Dict[str, Any]) -> List[str]:
        """Generate test for a standalone function"""
        lines = []
        
        func_name = func_spec.get('name', 'function')
        
        lines.extend([
            f'def test_{func_name}():',
            f'    """Test {func_name}"""',
            f'    # TODO: Implement test for {func_name}',
            f'    with pytest.raises(NotImplementedError):',
            f'        {func_name}()',
        ])
        
        return lines
    
    def _generate_integration_tests(self, spec: ModuleSpec) -> List[str]:
        """Generate integration tests"""
        lines = [
            '# Integration Tests',
            '',
            'def test_integration():',
            '    """Test integration with other modules"""',
            '    # TODO: Implement integration tests',
        ]
        
        for integration in spec.integrations:
            lines.append(f'    # Test integration with {integration}')
        
        lines.append('    pass')
        
        return lines
    
    def _generate_integration_notes(self, spec: ModuleSpec) -> str:
        """Generate notes on how to integrate the module"""
        lines = [
            f'# Integration Notes for {spec.name}',
            '',
            '## Import',
            f'```python',
            f'from saraphina.{spec.name} import *',
            f'```',
            '',
            '## Usage',
        ]
        
        # Add usage examples for classes
        for class_spec in spec.classes:
            class_name = class_spec.get('name')
            lines.extend([
                f'```python',
                f'{class_name.lower()} = {class_name}()',
                f'# Use {class_name.lower()} methods here',
                f'```',
                ''
            ])
        
        # Add integration points
        if spec.integrations:
            lines.extend([
                '## Integration Points',
                ''
            ])
            for integration in spec.integrations:
                lines.append(f'- Integrates with: `{integration}`')
            lines.append('')
        
        # Add dependencies
        if spec.dependencies:
            lines.extend([
                '## Dependencies',
                '```bash',
                f'pip install {" ".join(spec.dependencies)}',
                '```',
                ''
            ])
        
        return '\n'.join(lines)
    
    def write_module(self, generated: GeneratedModule) -> Dict[str, str]:
        """
        Write generated module and test files to disk.
        
        Args:
            generated: GeneratedModule with content
        
        Returns:
            Dict with 'module' and 'test' paths
        """
        # Write module file
        module_path = Path(generated.module_file)
        module_path.write_text(generated.module_content, encoding='utf-8')
        logger.info(f"Wrote module: {module_path}")
        
        # Write test file
        test_path = Path(generated.test_file)
        test_path.parent.mkdir(parents=True, exist_ok=True)
        test_path.write_text(generated.test_content, encoding='utf-8')
        logger.info(f"Wrote test: {test_path}")
        
        # Write integration notes
        notes_path = module_path.parent.parent / "docs" / f"{module_path.stem}_integration.md"
        notes_path.parent.mkdir(parents=True, exist_ok=True)
        notes_path.write_text(generated.integration_notes, encoding='utf-8')
        logger.info(f"Wrote integration notes: {notes_path}")
        
        return {
            'module': str(module_path),
            'test': str(test_path),
            'notes': str(notes_path)
        }
    
    def create_from_description(self, description: str) -> ModuleSpec:
        """
        Create a ModuleSpec from natural language description.
        
        This is a simplified parser. In production, this would use
        GPT-4 to parse the description into a structured spec.
        
        Args:
            description: Natural language module description
        
        Returns:
            ModuleSpec
        """
        # Simple keyword-based parsing
        # In production, use GPT-4 for better parsing
        
        words = description.lower().split()
        
        # Extract module name (first noun-like word)
        name = "new_module"
        for word in words:
            if len(word) > 3 and word.isalpha():
                name = word
                break
        
        # Detect if it needs a class
        has_class = any(keyword in description.lower() 
                       for keyword in ['manager', 'handler', 'processor', 'engine'])
        
        classes = []
        if has_class:
            class_name = ''.join(word.capitalize() for word in name.split('_'))
            classes.append({
                'name': class_name,
                'description': f'{class_name} for {name}',
                'methods': [
                    {
                        'name': 'process',
                        'description': 'Process data',
                        'parameters': [{'name': 'data', 'type': 'Any'}],
                        'returns': 'Dict[str, Any]'
                    }
                ]
            })
        
        return ModuleSpec(
            name=name,
            description=description,
            classes=classes,
            functions=[],
            dependencies=[],
            integrations=[],
            has_cli=False,
            has_config=False
        )


# CLI interface
if __name__ == "__main__":
    import sys
    import json
    
    logging.basicConfig(level=logging.INFO)
    
    if len(sys.argv) > 1:
        description = ' '.join(sys.argv[1:])
        
        creator = ModuleCreator()
        spec = creator.create_from_description(description)
        
        print(f"\nğŸ“¦ Generated ModuleSpec:")
        print(json.dumps(spec.to_dict(), indent=2))
        
        print(f"\nğŸ”¨ Creating module...")
        generated = creator.create_module(spec)
        
        print(f"\nâœ… Generated:")
        print(f"  Module: {generated.module_file}")
        print(f"  Test: {generated.test_file}")
        print(f"\nğŸ“ Integration Notes:")
        print(generated.integration_notes)
    
    else:
        print("Usage: python module_creator.py <module description>")
        print("Example: python module_creator.py 'speech recognition handler'")
